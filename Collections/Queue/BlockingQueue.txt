========================================================================================================================
                                   BlockingQueue
========================================================================================================================                                 


Hierarchy :
-------------
      Collection (Interface)
   ‚îî‚îÄ‚îÄ Queue (Interface)
         ‚îú‚îÄ‚îÄ Deque (Interface)
         ‚îÇ     ‚îú‚îÄ‚îÄ LinkedList
         ‚îÇ     ‚îî‚îÄ‚îÄ ArrayDeque
         ‚îú‚îÄ‚îÄ PriorityQueue
         ‚îî‚îÄ‚îÄ BlockingQueue (in java.util.concurrent)

========================================================================================================================

BlockingQueue :
================
üß© 1Ô∏è‚É£ Definition :
-------------------
 -> BlockingQueue is an interface in the java.util.concurrent package.
 -> It extends the Queue interface and adds blocking operations that wait for the queue to become non-empty or non-full.
So it is a thread-safe queue that supports operations which block when:
  -> You try to take an element from an empty queue.
  -> You try to put an element into a full queue.

‚öôÔ∏è 2Ô∏è‚É£ Why (Purpose)
----------------------
In normal queues like LinkedList, ArrayDeque, or PriorityQueue:
   -> If the queue is empty and you try to remove ‚Üí it gives null or NoSuchElementException.
   -> If full ‚Üí you must manually handle it.
But in a multithreaded environment, you often need:
   -> One thread producing elements (Producer).
   -> Another thread consuming them (Consumer).
üëâ BlockingQueue automatically handles waiting:
   -> Producer waits if the queue is full
   -> Consumer waits if the queue is empty.
That‚Äôs why it‚Äôs heavily used in Producer-Consumer Problems.

üïí 3Ô∏è‚É£ When to Use
--------------------
‚úÖ Use BlockingQueue when:
  -> You are building multithreaded programs.
  -> You need thread-safe communication between producer and consumer threads.
  -> You want automatic blocking instead of manual synchronization (wait() / notify()).

 üîß 4Ô∏è‚É£ How (Methods)
-----------------------
In addition to normal Queue methods, it provides four kinds of put/take variations: 

| Type                 | Insert (Add Element)   | Remove (Take Element) | Behavior                         |
| -------------------- | ---------------------- | --------------------- | -------------------------------- |
| **Throws Exception** | `add(e)`               | `remove()`            | Fails immediately if full/empty  |
| **Special Value**    | `offer(e)`             | `poll()`              | Returns false/null if full/empty |
| **Blocks**           | `put(e)`               | `take()`              | Waits indefinitely               |
| **Times Out**        | `offer(e, time, unit)` | `poll(time, unit)`    | Waits for a time limit           |

Here‚Äôs your **BlockingQueue implementations** in a clean table format for easy copy-paste:

| Class                   | Description                                                             |
| ----------------------- | ----------------------------------------------------------------------- |
| `ArrayBlockingQueue`    | Bounded (fixed size) queue backed by an array.                          |
| `LinkedBlockingQueue`   | Usually unbounded (or optionally bounded), uses linked nodes.           |
| `PriorityBlockingQueue` | Unbounded priority-based queue (like `PriorityQueue`).                  |
| `DelayQueue`            | Elements become available only after a delay.                           |
| `SynchronousQueue`      | No internal capacity (handoff queue) ‚Äî one insert must wait for a take. |
| `LinkedTransferQueue`   | Similar to `LinkedBlockingQueue` but supports `transfer()` method.      |


Excellent üëè ‚Äî you‚Äôre now entering one of the most **important** and **advanced** parts of the Java Queue hierarchy:
‚û°Ô∏è **`BlockingQueue`** ‚Äî mainly used in **multithreading and concurrent programming**.

Let‚Äôs break it down **step-by-step (Definition ‚Üí Why ‚Üí When ‚Üí How ‚Üí Implementations ‚Üí Example).**

---

## üß© 1Ô∏è‚É£ Definition

**`BlockingQueue`** is an **interface** in the `java.util.concurrent` package.
It **extends** the `Queue` interface and adds **blocking operations** that wait for the queue to become non-empty or non-full.

```java
public interface BlockingQueue<E> extends Queue<E> 
```

So it is a **thread-safe queue** that supports operations which **block** when:

* You try to **take** an element from an **empty** queue.
* You try to **put** an element into a **full** queue.

---

## ‚öôÔ∏è 2Ô∏è‚É£ Why (Purpose)

In normal queues like `LinkedList`, `ArrayDeque`, or `PriorityQueue`:

* If the queue is empty and you try to remove ‚Üí it gives `null` or `NoSuchElementException`.
* If full ‚Üí you must manually handle it.

But in a **multithreaded environment**, you often need:

* One thread **producing** elements (Producer).
* Another thread **consuming** them (Consumer).

üëâ `BlockingQueue` automatically **handles waiting**:

* Producer waits if the queue is full.
* Consumer waits if the queue is empty.

That‚Äôs why it‚Äôs heavily used in **Producer-Consumer Problems**.

---

## üïí 3Ô∏è‚É£ When to Use

‚úÖ Use `BlockingQueue` when:

* You are building **multithreaded** programs.
* You need **thread-safe communication** between producer and consumer threads.
* You want automatic blocking instead of manual synchronization (`wait()` / `notify()`).

---

## üîß 4Ô∏è‚É£ How (Methods)

In addition to normal `Queue` methods, it provides four kinds of **put/take variations**:

| Type                 | Insert (Add Element)   | Remove (Take Element) | Behavior                         |
| -------------------- | ---------------------- | --------------------- | -------------------------------- |
| **Throws Exception** | `add(e)`               | `remove()`            | Fails immediately if full/empty  |
| **Special Value**    | `offer(e)`             | `poll()`              | Returns false/null if full/empty |
| **Blocks**           | `put(e)`               | `take()`              | Waits indefinitely               |
| **Times Out**        | `offer(e, time, unit)` | `poll(time, unit)`    | Waits for a time limit           |

---

## üß± 5Ô∏è‚É£ Common Implementations

| Class                   | Description                                                             |
| ----------------------- | ----------------------------------------------------------------------- |
| `ArrayBlockingQueue`    | Bounded (fixed size) queue backed by an array.                          |
| `LinkedBlockingQueue`   | Usually unbounded (or optionally bounded), linked nodes.                |
| `PriorityBlockingQueue` | Unbounded priority-based queue (like `PriorityQueue`).                  |
| `DelayQueue`            | Elements become available only after a delay.                           |
| `SynchronousQueue`      | No internal capacity (handoff queue) ‚Äî one insert must wait for a take. |
| `LinkedTransferQueue`   | Similar to LinkedBlockingQueue but supports `transfer()` method.        |

---

## üíª 6Ô∏è‚É£ Simple Example

```java
import java.util.concurrent.*;

public class BlockingQueueExample {
    public static void main(String[] args) {
        BlockingQueue<String> queue = new ArrayBlockingQueue<>(3);

        // Producer Thread
        new Thread(() -> {
            try {
                queue.put("A");
                System.out.println("Produced: A");
                Thread.sleep(1000);

                queue.put("B");
                System.out.println("Produced: B");
                Thread.sleep(1000);

                queue.put("C");
                System.out.println("Produced: C");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();

        // Consumer Thread
        new Thread(() -> {
            try {
                Thread.sleep(2000);
                System.out.println("Consumed: " + queue.take());
                Thread.sleep(2000);
                System.out.println("Consumed: " + queue.take());
                Thread.sleep(2000);
                System.out.println("Consumed: " + queue.take());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }
}
```

üß† Output (order may vary slightly):

```
Produced: A
Produced: B
Produced: C
Consumed: A
Consumed: B
Consumed: C
```

---

## üß© 7Ô∏è‚É£ Summary Table

| Feature         | Description                                   |
| --------------- | --------------------------------------------- |
| Package         | `java.util.concurrent`                        |
| Type            | Interface                                     |
| Extends         | `Queue`                                       |
| Thread-Safe     | ‚úÖ Yes                                         |
| Blocking        | ‚úÖ Yes                                         |
| Typical Use     | Producer-Consumer, thread communication       |
| Key Methods     | `put()`, `take()`, `offer()`, `poll()`        |
| Implementations | ArrayBlockingQueue, LinkedBlockingQueue, etc. |

