===========================================================================================================
                                 LinkedHashMap
===========================================================================================================
üî∂ 1. What is LinkedHashMap?
-------------------------------
A LinkedHashMap is a Map in Java that:
‚úî Stores elements as key‚Äìvalue pairs (like HashMap)
‚úî Maintains insertion order using a doubly-linked list
‚úî Allows one null key and many null values
‚úî Provides faster iteration compared to HashMap
üìå Internally:
Uses HashTable + Doubly Linked List
HashTable ‚Üí fast searching
Linked List ‚Üí maintains order

üî∂ 2. Why LinkedHashMap?
--------------------------
Use LinkedHashMap when you want:
‚úî Order + Fast Search
HashMap is fast but does not maintain order.
LinkedHashMap maintains order + same speed.
‚úî Predictable iteration
Iteration order is 100% predictable.
‚úî Cache creation (LRU Cache)
LinkedHashMap supports access-order mode, perfect for making an LRU cache.

üî∂ 3. When to use LinkedHashMap?
-----------------------------------
Situation	Use LinkedHashMap?	Reason
Maintain order of elements	‚úî Yes	Keeps insertion order
Don‚Äôt care about order	‚ùå No	Use HashMap (faster, lighter)
Need LRU cache	‚úî Yes	Supports access-order
Want sorted keys	‚ùå No	Use TreeMap
Need frequent iteration	‚úî Yes	Iteration is faster than HashMap

üî∂ 4. How LinkedHashMap Works? (Internal Working)
----------------------------------------------------
‚úî Uses:
HashMap buckets to store entries
Doubly Linked List to maintain order
Each entry stored like:
    prev <‚Äî> key=value <‚Äî> next

Two types of ordering:
1Ô∏è‚É£ Insertion Order (default)
2Ô∏è‚É£ Access Order
    -> Every time you do: get(), entry moves to end
    -> Used for LRU Cache


üîπ LinkedHashMap Constructors :
 ---------------------------------------------------------------------------------------------------------------------------------------------------   
Constructor	                                        |       Description
----------------------------------------------------------------------------------------------------------------------------------------------------
LinkedHashMap()	                                    |    Default constructor ‚Äî initial capacity 16, load factor 0.75, insertion order
LinkedHashMap(int initialCapacity)	                |    Custom initial capacity, default load factor 0.75
LinkedHashMap(int initialCapacity, float loadFactor)|	Custom capacity + load factor, insertion order
LinkedHashMap(int initialCapacity, float loadFactor,| 
                   boolean accessOrder)	                Custom capacity + load factor + access order (true = access order, false = insertion order)
LinkedHashMap(Map<? extends K, ? extends V> m)	    |    Creates a LinkedHashMap with all entries from another map, preserving insertion order



üîπ LinkedHashMap Methods
Basic Methods (Inherited from HashMap / Map)
| #  | Method                                                                                   | Description                                | Example                                                                           |
| -- | ---------------------------------------------------------------------------------------- | ------------------------------------------ | --------------------------------------------------------------------------------- |
| 1  | `put(K key, V value)`                                                                    | Add or update key-value                    | `map.put(1,"Apple");`                                                             |
| 2  | `get(Object key)`                                                                        | Get value by key                           | `map.get(1);`                                                                     |
| 3  | `remove(Object key)`                                                                     | Remove entry by key                        | `map.remove(1);`                                                                  |
| 4  | `remove(Object key, Object value)`                                                       | Remove entry if key and value match        | `map.remove(1,"Apple");`                                                          |
| 5  | `putIfAbsent(K key, V value)`                                                            | Add only if key not present                | `map.putIfAbsent(2,"Banana");`                                                    |
| 6  | `getOrDefault(Object key, V defaultValue)`                                               | Get value or default                       | `map.getOrDefault(3,"NotFound");`                                                 |
| 7  | `replace(K key, V value)`                                                                | Replace value for key                      | `map.replace(1,"Mango");`                                                         |
| 8  | `replace(K key, V oldValue, V newValue)`                                                 | Replace only if old value matches          | `map.replace(1,"Mango","Papaya");`                                                |
| 9  | `compute(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)`          | Compute new value                          | `map.compute(1,(k,v)->v+"!");`                                                    |
| 10 | `computeIfAbsent(K key, Function<? super K,? extends V> mappingFunction)`                | Compute if absent                          | `map.computeIfAbsent(4,k->"Orange");`                                             |
| 11 | `computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction)` | Compute if present                         | `map.computeIfPresent(1,(k,v)->v+"Z");`                                           |
| 12 | `merge(K key, V value, BiFunction<? super V,? super V,? extends V> remappingFunction)`   | Merge value                                | `map.merge(1,"++",(oldVal,newVal)->oldVal+newVal);`                               |
| 13 | `containsKey(Object key)`                                                                | Check if key exists                        | `map.containsKey(1);`                                                             |
| 14 | `containsValue(Object value)`                                                            | Check if value exists                      | `map.containsValue("Apple");`                                                     |
| 15 | `size()`                                                                                 | Number of entries                          | `map.size();`                                                                     |
| 16 | `isEmpty()`                                                                              | Check if empty                             | `map.isEmpty();`                                                                  |
| 17 | `clear()`                                                                                | Remove all entries                         | `map.clear();`                                                                    |
| 18 | `keySet()`                                                                               | Return keys in order                       | `map.keySet();`                                                                   |
| 19 | `values()`                                                                               | Return values in order                     | `map.values();`                                                                   |
| 20 | `entrySet()`                                                                             | Return entries in order                    | `map.entrySet();`                                                                 |
| 21 | `forEach(BiConsumer<? super K,? super V> action)`                                        | Iterate in order                           | `map.forEach((k,v)->System.out.println(k+":"+v));`                                |
| 22 | `clone()`                                                                                | Shallow copy                               | `LinkedHashMap<Integer,String> copy=(LinkedHashMap<Integer,String>) map.clone();` |
| 23 | `equals(Object o)`                                                                       | Check equality                             | `map.equals(otherMap);`                                                           |
| 24 | `hashCode()`                                                                             | Map hash code                              | `map.hashCode();`                                                                 |
| 25 | `toString()`                                                                             | Map as string                              | `map.toString();`                                                                 |
| 26 | `protected boolean removeEldestEntry(Map.Entry<K,V> eldest)`                             | Override to auto-remove oldest entry (LRU) | `protected boolean removeEldestEntry(Map.Entry<K,V> e){ return size()>3; }`       |


LinkedHashMap-Specific Method :
---------------------------------
| Method                                                       | Description                                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------------------------- |
| `protected boolean removeEldestEntry(Map.Entry<K,V> eldest)` | Used to automatically remove oldest entry (for LRU cache), override in subclass |
